<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Trabajo_de_Grado_Tatiana_Porras</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="Estilo1.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
  <!-- pandoc-eqnos: equation style -->
  <style>
    .eqnos { display: inline-block; position: relative; width: 100%; }
    .eqnos br { display: none; }
    .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
  </style>
</head>
<body>
<div id="main-title">
<p>ALGORITMO VORAZ ITERATIVO CON MULTI-VECINDAD APLICADO AL PROBLEMA DE SECUENCIACIÓN DIFUSO MULTIPRODUCTO Y MULTIETAPAS</p>
</div>
<div id="datos-varios">
<p>Trabajo para optar al título de:<br />
INGENIERA INDUSTRIAL<br />
<br />
<br />
Tatiana Porras Cortés 20092015073<br />
Correo: tatiporras96@gmail.com<br />
<br />
LINDSAY ÁLVAREZ POMAR<br />
Directora del trabajo de grado<br />
<img src="EscudoUD1.png" id="im1" alt="escudito" /><br />
UNIVERSIDAD DISTRITAL FRANCISCO JOSÉ DE CALDAS<br />
FACULTAD DE INGENIERÍA<br />
PROYECTO CURRICULAR DE INGENIERÍA INDUSTRIAL<br />
Bogotá D.C., Colombia. 2021-05-30</p>
</div>
<h1 id="título">TÍTULO</h1>
<p>“ALGORITMO VORAZ ITERATIVO CON MULTI-VECINDAD APLICADO AL PROBLEMA DE SECUENCIACIÓN DIFUSO MULTIPRODUCTO Y MULTIETAPAS”</p>
<h1 id="resumen">RESUMEN</h1>
<p>El Algoritmo Voraz Iterativo con Multi-Vecindad (MNIG por sus siglas en inglés Multi-Neighborhood Iterated Greedy algorithm) aplicado al Problema de Secuenciación Difuso Multiproducto y Multietapas (FMMSP por sus siglas en inglés Fuzzy Multiproduct Multistage Scheduling Problem), no ha sido tratado en la literatura científica internacional. En este trabajo se exploró esta combinación nueva. Para ello, se modificó el algoritmo MNIG y se utilizó para resolver el modelo FMMSP. El modelo FMMSP en notación de scheduling es el modelo <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>.</p>
<p>Se implementó el algoritmo MNIG en Python, y al aplicarlo al modelo FMMSP se encontró que el algoritmo MNIG es al menos tan bueno como el algoritmo DBSA-LS, e inclusive mostró mejora en la solución promedio. Esto se comprobó con la única instancia disponible que publicaron los creadores del modelo FMMSP, la cual fue resuelta por el algoritmo MNIG en 0.83 segundos en promedio.</p>
<p><strong>Palabras Clave</strong>: Algoritmo Voraz Iterativo, Multi-vecindad, Secuenciación, Números Triangulares Difusos, Multiproducto, Multietapas.<br />
<br />
<br />
</p>
<h1 id="abstract">ABSTRACT</h1>
<p>The Multi-neighborhood Iterated Greedy algorithm (acronymized as MNIG) applied to the Fuzzy Multiproduct Multistage Scheduling Problem (acronymized as FMMSP), has not been treated in the international scientific literature. This work explored this new combination. For that, the MNIG algorithm was modified and used to solve the FMMSP model. In scheduling notation, the FMMSP model is <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>.</p>
<p>The MNIG algorithm was implemented in Python, and by applying it to the FMMSP model, it was found that the MNIG algorithm is at least as good as the DBSA-LS algorithm, and it even showed an improvement in the average solution value. This was proven with the only available instance that was published by the creators of the FMMSP model, which was solved by the MNIG algorithm in 0.83 seconds on average.</p>
<p><strong>Keywords</strong>: Iterated Greedy Algorithm, Multi-neighborhood, Scheduling, Triangular Fuzzy Numbers, Multiproduct, Multistage.</p>
<h1 id="introducción">INTRODUCCIÓN</h1>
<p>El presente trabajo de tesis de pregrado ha hecho un aporte a un pequeño a mi conocimiento sobre los sistemas flow shop flexible con tiempos de procesamiento representados con números triangulares difusos, multiproducto y multietapa. Así como mi conocimiento sobre cómo obtener secuencias con un makespan relativamente bajo para este sistema, usando una metaheurística voraz, con multi-vecindad, e iterativo. La palabra ‘makespan’ significa el tiempo de terminación máximo de la secuencia.</p>
<p>Este trabajo no solamente tiene que ser útil para mi conocimiento, sino que también puede servir para el conocimiento de quien lo lea, pues esta combinación entre modelo y algoritmo, no había sido realizada antes.</p>
<p>Para ser más precisos: en el presente trabajo se eligió el tema de secuenciación, mejor conocido por su nombre en inglés como “scheduling.” Dentro de este tema se revisó el estado del arte (consultando las bases de datos internacionales, a las que tiene acceso la Universidad Distrital), se encontró un modelo de scheduling que ha sido poco estudiado, y por aparte se encontró un algoritmo que nunca ha sido aplicado al modelo, sino hasta ahora.</p>
<p>El modelo encontrado <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span> es llamado FMMSP que significa Fuzzy Multiproduct Multistage Scheduling Problem, que en español se podría traducir como Problema de Secuenciación Difuso Multiproducto y Multietapas, y su representación en notación de scheduling es <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>. Es un modelo interesante de ser estudiado pues incluye números difusos triangulares, múltiples productos, y múltiples etapas.</p>
<p>El algoritmo encontrado <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span> es llamado MNIG que significa Multi-Neighborhood Iterated Greedy algorithm. En español se traduce como algoritmo Voraz Iterativo con Multi-Vecindad. Se ha encontrado que este algoritmo sirve para resolver problemas de scheduling <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span>.</p>
<p>Lo novedoso resultó en que dicho algoritmo jamás había sido aplicado al modelo hasta ahora. Para realizar este trabajo se hizo necesario modificar el algoritmo, pues el algoritmo original no se puede aplicar directamente al modelo. En este trabajo se comprobó que el algoritmo MNIG se puede adaptar para encontrar soluciones del modelo FMMSP, y no solo eso, pues también se comprobó que las soluciones en promedio son mejores que las de los cuatro algoritmos que ya han sido aplicados al modelo FMMSP, específicamente los algoritmos: DBSA-LS, BDBSA, MBSA, e IGA. Esto se comprobó usando la única instancia publicada por los autores del modelo FMMSP <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span>.</p>
<p>El algoritmo MNIG fue implementado en Python, y fue específicamente diseñado para tratar el modelo FMMSP. También se le hizo benchmarking al algoritmo MNIG usando 95 instancias de Taillard, que son instancias del problema flow shop básico. A pesar de que en total son 120 instancias de Taillard, solamente se usaron 95, porque las últimas 25 instancias son tan grandes, que esta implementación del algoritmo MNIG se tarda más de 24 horas para realizar una sola iteración, y esto es porque el algoritmo MNIG en este caso fue implementado para resolver el modelo FMMSP, no para resolver el modelo flow shop básico (pero indudablemente si se usara una instancia del modelo FMMSP con muchas máquinas y productos, la ejecución sería lenta, por lo que si se quisiera usar este algoritmo para esas instancias, primero se debería optimizar, lo cual se sale del alcance de este trabajo. Acá lo que cuenta es comprobar que el algoritmo MNIG es competitivo, e inclusive aporta mejores soluciones en promedio, que los otros cuatro algoritmos).</p>
<h1 id="planteamiento-del-problema">PLANTEAMIENTO DEL PROBLEMA</h1>
<p>El problema que se resolvió con esta tesis, es el de explorar el algoritmo MNIG como candidato para encontrar secuencias de un sistema de producción del tipo FMMSP, de modo tal que dichas secuencias tengan un makespan bajo, comparado con los makespan encontrados con los algoritmos DBSA-LS, BDBSA, MBSA, e IGA.</p>
<h2 id="elementos-del-problema">Elementos del Problema</h2>
<p>Según lo anterior, los elementos del problema son:</p>
<ul>
<li>Se requieren secuencias con bajos makespan en el modelo FMMSP, denotado como <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>. Estas secuencias son llamadas ‘soluciones.’</li>
<li>El algoritmo MNIG tiene potencial para encontrar dichas soluciones en un tiempo prudente. Los resultados se pueden comparar a otros cuatro algoritmos que ya han sido usados en el modelo FMMSP.</li>
</ul>
<p>Este trabajo de tesis logró resolver estos elementos del problema, de la siguiente manera, respectivamente:</p>
<ul>
<li>El algoritmo MNIG ha servido para encontrar soluciones del modelo FMMSP.</li>
<li>Las soluciones encontradas por el algoritmo MNIG son al menos igual de buenas, y mejores en promedio, que las soluciones encontradas por los algoritmos DBSA-LS, BDBSA, MBSA, e IGA.</li>
</ul>
<h2 id="pregunta-del-problema">Pregunta del Problema</h2>
<p>¿Cómo puede el algoritmo MNIG encontrar soluciones para el modelo FMMSP?</p>
<p><strong>Respuesta encontrada en este trabajo</strong>: Implementando el algoritmo MNIG en Python, y aplicándolo a instancias del modelo FMMSP.</p>
<h2 id="subpreguntas-del-problema">Subpreguntas del Problema</h2>
<p>¿Cómo puede implementarse el algoritmo MNIG, para obtener resultados del modelo FMMSP, denotado como <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>?</p>
<p><strong>Respuesta</strong>: El algoritmo MNIG puede ser implementado en Python, usando un paradigma de programación funcional, porque el algoritmo MNIG viene subdividido en cuatro algoritmos, cada uno de los cuales puede ser encapsulado dentro de una función, de modo que cada función pueda llamar a las otras según como está escrito en la definición del algoritmo MNIG. Esto se presta para ser implementado usando un paradigma de programación funcional, en el que se crean funciones que se llaman las unas a las otras.</p>
<p>¿De qué forma puede la implementación del algoritmo aportar resultados útiles,como por ejemplo,una secuencia de trabajos?</p>
<p><strong>Respuesta</strong>: Usando una interfaz de línea de comandos. Toda interfaz de línea de comandos básica, tiene la facultad de imprimir resultados en pantalla. Estos resultados se pueden copiar en archivos de texto para ser analizados.</p>
<p>¿Cómo se comparan los resultados del algoritmo con los resultados de los otros cuatro algoritmos?</p>
<p><strong>Respuesta</strong>: El algoritmo MNIG sorprendió en sus resultados, pues resultó ser al menos igual de bueno, y mejor en promedio, que los algoritmos DBSA-LS, BDBSA, MBSA, e IGA.</p>
<h1 id="objetivos">OBJETIVOS</h1>
<h2 id="objetivo-general">Objetivo General</h2>
<ul>
<li>Encontrar soluciones a través del algoritmo MNIG para el modelo FMMSP.</li>
</ul>
<h2 id="objetivos-específicos">Objetivos Específicos</h2>
<ul>
<li>Implementar el algoritmo MNIG de modo que se puedan obtener resultados del modelo FMMSP, denotado como <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>.</li>
<li>Obtener secuencias del modelo FMMSP usando la implementación realizada.</li>
<li>Comparar el algoritmo MNIG aplicado al modelo FMMSP con los otros cuatro algoritmos que se han aplicado al modelo FMMSP.</li>
<li>Establecer si tiene sentido o no aplicar el algoritmo MNIG al modelo FMMSP, o si es preferible buscar otros algoritmos incluidos los que ya han sido probados.</li>
<li>Determinar la efectividad del algoritmo MNIG, no solo respecto al modelo FMMSP sino también respecto al modelo flow shop general.</li>
</ul>
<h1 id="justificación">JUSTIFICACIÓN</h1>
<p>Se propone este trabajo porque en el mundo académico existe una necesidad de comprobar que nuevos algoritmos den resultados comparables a viejos algoritmos, al ser aplicados a los modelos. En particular en el mundo del scheduling ocurre que un algoritmo que se usa para un tipo de modelos pueda ser adaptado para tratar otro tipo de modelos diferente. Este trabajo se justifica como un aporte de prueba de que el algoritmo MNIG sirve para resolver el modelo FMMSP <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span> en comparación a otros algoritmos ya establecidos.</p>
<p><strong>¿Cuál es el problema de investigación?</strong>: El problema es que en toda la historia registrada de la humanidad, nunca se había aplicado el algoritmo MNIG al modelo de scheduling FMMSP (para ello se revisaron las bases de datos internacionales a que tiene acceso la Universidad Distrital, y hasta la fecha no se había resuelto este problema). Se podría pensar que cualquier metaheurística que existe se puede aplicar a cualquier modelo de scheduling, sin embargo esto no se puede asumir como cierto hasta que no se demuestre, y hasta ahora se ha demostrado, con este trabajo, que el algotimo MNIG es competente para encontrar soluciones del modelo FMMSP.</p>
<p>Pero, ¿Qué se entiende al decir que un algoritmo es competente o no? En este contexto, se entiende que un algoritmo es competente si produce soluciones de calidad en un tiempo razonable. Para saber si las soluciones son de calidad, se compara aquí el algoritmo MNIG con otros cuatro algoritmos DBSA-LS, BDBSA, MBSA, e IGA (estos se explican en la sección del marco de referencia), los cuales tienen comprobada efectividad para encontrar soluciones en el modelo FMMSP. Esta comparación se hizo con la única instancia publicada por los autores del modelo FMMSP.</p>
<p><strong>¿Cómo ha sido resuelto este problema de scheduling?</strong>: El modelo FMMSP ha sido resuelto usando cuatro algoritmos, específicamente los algoritmos DBSA-LS, BDBSA, MBSA, e IGA. Hasta donde se sabe (tras hacer una revisión profunda de las bases de datos internacionales a las que tiene acceso la Universidad Distrital), estos son los únicos cuatro algoritmos con que se ha solucionado el modelo FMMSP. Por ello el algoritmo MNIG fue comparado con estos cuatro algoritmos, y resultó ser que el algoritmo MNIG es competitivo con los otros cuatro al encontrar soluciones del modelo FMMSP, resolviendo la única instancia publicada por los autores del modelo FMMSP en 0.83 segundos en promedio.</p>
<p><strong>¿Cuál es el aporte a la solución de éste problema de scheduling en particular?</strong>: En este trabajo, el aporte a la solución del modelo FMMSP, es que se aportó un nuevo algoritmo de comprobada efectividad para solucionar el modelo FMMSP. Este nuevo algoritmo es el algoritmo MNIG. Con la única instancia pública internacional que existe del modelo FMMSP se comprobó la competitividad del algoritmo MNIG para resolver el modelo FMMSP.</p>
<p><strong>¿Por qué hay que solucionar este problema?</strong>: Porque nunca se había hecho y porque hay un interés científico por avanzar nuestro conocimiento sobre los límites que unen a las metaheurísticas y los modelos de scheduling. Debido a la naturaleza NP-Hard de los modelos derivados de flow shop (como lo es el modelo FMMSP), aún no existe forma de garantizar la optimalidad de las soluciones encontradas por las metaheurísticas, y por eso existe cierta competencia entre diferentes metaheurísticas que usan diferentes estrategias para buscar soluciones en el espacio de búsqueda. Esta competencia sigue abierta para el modelo FMMSP, y aunque el algoritmo MNIG fue diseñado para problemas muy diferentes, en este trabajo se ha logrado adaptar el algoritmo MNIG para tratar el modelo FMMSP y encontrar soluciones al mismo, soluciones competitivas con las de los algoritmos DBSA-LS, BDBSA, MBSA, e IGA.</p>
<p><strong>¿Qué sucede si no solucionamos este problema identificado?</strong>: Si no se solucionara este problema, no avanzaría nuestro conocimiento sobre el modelo FMMSP y sus soluciones. El modelo FMMSP es un modelo que se puede encontrar en sistemas de producción reales, nada más el hecho de que el modelo FMMSP incluye números difusos triangulares (F es por Fuzzy), muestra que el modelo FMMSP puede ser aplicado a sistemas de producción colombianos, en donde no hay una fuerte estandarización, porque si las estaciones de trabajo tienen tiempos de procesamiento fuertemente estandarizados, ya no se hacen necesarios los números triangulares difusos, y resulta más fácil y razonable usar simples números para representar los tiempos de procesamiento. En cambio, en sistemas donde no hay una fuerte estandarización, puede tener sentido usar números triangulares difusos para representar los tiempos de producción de las estaciones de trabajo, porque así se representa la incertidumbre sobre el verdadero tiempo de producción, usando las tres partes que forman un número triangular difuso: el tiempo optimista de producción, el tiempo promedio de producción, y el tiempo pesimista de producción (esto se puede ver también en la sección del marco de referencia).</p>
<h1 id="alcances-y-limitaciones-del-proyecto">ALCANCES Y LIMITACIONES DEL PROYECTO</h1>
<p><strong>Alcances:</strong> Los alcances de este proyecto están bien definidos. Parte del alcance consiste en escribir un algoritmo en Python, específicamente implementar el algoritmo MNIG en un programa de consola de Python. En el proyecto también se incluye la tesis de grado en la que se compararán los resultados del algoritmo implementado en este proyecto con los de otros cuatro algoritmos (DBSA-LS, BDBSA, MBSA, e IGA) aplicados al modelo FMMSP <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>. Dicha tesis será entregada a la Universidad Distrital.</p>
<h1 id="marco-de-referencia">MARCO DE REFERENCIA</h1>
<p>El marco de referencia se enfoca en el scheduling de los sistemas de producción tipo FMMSP, en el algoritmo MNIG que es un tipo de metaheurística, y en los otros cuatro algoritmos que son DBSA-LS, BDBSA, MBSA, e IGA.</p>
<h2 id="antecedentes-y-marco-teórico">Antecedentes y Marco Teórico</h2>
<p>En los antecedentes encontramos dos temas pilares: el scheduling, y las metaheurísticas. Del libro de scheduling de Pinedo <span class="citation" data-cites="schedPinedo">(Pinedo 2016)</span> se tiene una interrelación entre los temas de los antecedentes. Se han creado multitud de heurísticas y metaheurísticas para resolver los problemas de scheduling. También ha ocurrido que muchas metaheurísticas pueden ser modificadas para tratar otros problemas diferentes de scheduling.</p>
<p>El scheduling es un proceso de toma de decisiones en el que se asignan recursos a los trabajos (u ordenes) a realizar. En esta asignación los trabajos se van realizando en virtud de los recursos que le han sido asignados. En otras palabras, no se puede completar un trabajo que no ha sido asignado a los recursos que lo llevan a cabo. En la decisión de cómo realizar dichas asignaciones surge la importancia del scheduling, por el hecho de que distintas asignaciones conllevan a diferentes tiempos de realización de los trabajos. <span class="citation" data-cites="schedPinedo">(Pinedo 2016)</span></p>
<p>La medida de desempeño más ubicua del scheduling es el tiempo de terminación máximo, también conocido como makespan, que es el tiempo en que se termina el último trabajo de la secuencia. En este sentido, el makespan representa el tiempo que toma realizar todos los trabajos. En el scheduling, lo más comúm es que la función objetivo sea minimizar el makespan, es decir, minimizar el máximo de los tiempos de terminación de los trabajos de la secuencia. <span class="citation" data-cites="schedPinedo">(Pinedo 2016)</span></p>
<p>Respecto a las heurísticas y metaheurísticas, en ambas se renuncia a la optimalidad, se renuncia a encontrar la mejor solución posible según determinada medida de desempeño, a cambio de encontrar soluciones aceptables en un tiempo prudente. <span class="citation" data-cites="metaTalbi">(Talbi 2009)</span></p>
<p>La notación del modelo FMMSP: <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>, fue creada con base en la notación tradicional de scheduling de Pinedo. <span class="citation" data-cites="schedPinedo">(Pinedo 2016)</span></p>
<p>En cuanto al algoritmo MNIG y la diferencia entre heurísticas y metaheurísticas, las metaheurísticas pueden abarcar un amplio abanico de problemas, mientras que las heurísticas se diseñan para un problema muy específico <span class="citation" data-cites="metaTalbi">(Talbi 2009)</span>. Acorde a lo anterior, el algoritmo MNIG es una metaheurística pues es un algoritmo que se puede usar para diversos tipos de problemas, y aunque originalmente no haya sido diseñado pensando en el modelo FMMSP <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span> se puede adaptar fácilmente sin cambiar la esencia de la metaheurística.</p>
<h2 id="marco-conceptual">Marco Conceptual</h2>
<p><strong>Scheduling:</strong> problemas de optimización en los que se establece una secuencia de trabajos en un sistema de producción, y se busca optimizar la medida de desempeño de interés en el sistema de producción.</p>
<p>Existe variedad de tipos de sistemas de producción, los primera división se hace en sistemas determinísticos y estocásticos. En los sistemas determinísticos se conoce con precisión los parámetros del sistema, mientras que en los sistemas estocásticos los parámetros tienen variabilidad. <span class="citation" data-cites="schedPinedo">(Pinedo 2016)</span></p>
<p>Luego están los sistemas de una sola máquina, que son sistemas teóricos que sirven para formular modelos más complejos, puesto que en los sistemas de producción reales rara vez se presenta el caso de una sola máquina. Después vienen los sistemas de máquinas paralelas en los que varias máquinas pueden procesar los mismos trabajos. En el siguiente nivel de complejidad se encuentran los sistemas tipo Flow Shop en los que los trabajos van fluyendo de una máquina a la siguiente en un mismo orden de máquinas. Sigue los sistemas tipo Job Shop en los que el orden de las máquinas puede ser diferente para cada trabajo. Por último los sistemas Open Shop en los que el orden de las máquinas por las que debe pasar cada trabajo puede ser parte de las decisiones de scheduling. <span class="citation" data-cites="schedPinedo">(Pinedo 2016)</span></p>
<p><strong>Metaheurística:</strong> Las metaheurísticas surgen como una alternativa a la situación en que la optimización de problemas toma demasiado tiempo. Cuando los problemas a optimizar son grandes y según aumentan de tamaño, el tiempo de optimización puede pasar de horas a días, a meses y años, e incluso mucho más tiempo. Los problemas realistas tienden a ser de gran tamaño, por lo que su optimización puede tomar años o más, incluso con los computadores más rápidos, en estos casos se usan metaheurísticas, que aunque no optimizan el problema, sí proveen soluciones aceptables en un tiempo razonable. <span class="citation" data-cites="metaTalbi">(Talbi 2009)</span></p>
<p>La complejidad de una metaheurística, y en general la complejidad de un algoritmo se mide con el tiempo que toma su ejecución en función del tamaño del problema. Dicho tiempo se denota usando la llamada notación O-grande, por ejemplo, si <span class="math inline">n</span> es el tamaño del problema, y <span class="math inline">O(n^2)</span> es la notación O-grande de un algoritmo dado, significa que el tiempo de resolución de dicho algoritmo aumenta al cuadrado del tamaño del problema <span class="math inline">n</span>. Esto no significa que el tiempo de resolución sea igual al cuadrado de <span class="math inline">n</span>, sino que el tiempo de resolución va aumentando con el tamaño del problema, y se acota por una cantidad proporcional al cuadrado del tamaño del problema. <span class="citation" data-cites="metaTalbi">(Talbi 2009)</span></p>
<p>Hay varios tipos de complejidad en la optimización de problemas y en los algoritmos. Se considera que un tiempo de resolución razonable es el llamado tiempo polinomial, así, un algoritmo de tiempo polinomial, es un algoritmo cuyo tiempo de resolución puede ser acotado con una función polinomial, y su notación O-grande respectiva será <span class="math inline">O(p(n))</span> donde <span class="math inline">p(n)</span> es una función polinomial del tamaño del problema <span class="math inline">n</span>. <span class="citation" data-cites="metaTalbi">(Talbi 2009)</span></p>
<p>Ocurre en los casos reales que muchas veces el tiempo de resolución de la optimización en un problema de scheduling, no puede ser acotado por una función polinomial. En estos casos la complejidad del problema es no polinomial, o NP por sus siglas en inglés. Una demostración importante, es que la optimización de modelos tipo Flow Shop y la optimización de modelos más complejos que se basen en el Flow Shop es de complejidad NP-Hard, que es una variante de los problemas no polinomiales. Lo anterior requiere que para estos modelos de scheduling se usen metaheurísticas para su resolución. <span class="citation" data-cites="flowCompl">(Garey, Jhonson, and Sethi 1976)</span></p>
<p><strong>Modelo FMMSP:</strong> El modelo FMMSP, denotado como <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>, representa un sistema de producción en el que los trabajos van pasando por etapas, y en cada etapa hay un número de máquinas (o unidades como les llaman en la literatura). Cada trabajo puede ser procesado solamente por una unidad en cada etapa. Cuando un trabajo pasa por todas las etapas se dice que está terminado. En el modelo FMMSP se busca optimizar el tiempo de terminación máximo de los trabajos, es decir, el tiempo en el que el último trabajo de la secuencia es terminado, medido desde el inicio de la producción. <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p>Para modelar el tiempo de producción en el modelo FMMSP se utilizan números difusos, en concreto número difusos triangulares. El hecho de que el tiempo de producción se represente mediante números difusos triangulares conlleva a que también el tiempo de terminación y el tiempo de inicio de cada trabajo sean también números difusos triangulares. Los números difusos triangulares son usados en situaciones donde se quiere representar la incertidumbre. Para el caso del modelo FMMSP se usan los números difusos triangulares para representar la incertidumbre en los tiempos de terminación, en otras palabras, un trabajo puede terminar o bien antes o bien después del momento en que se espera su terminación. En el modelo FMMSP cada número difuso triangular está compuesto a su vez por tres números. Esto es, cada tiempo de procesamiento, de terminación, o de inicio es una terna ordenada, en la que el primer número representa el tiempo optimista (bien sea de procesamiento, terminación, o inicio según el caso), el segundo número representa el tiempo esperado, y el tercer número representa el tiempo pesimista. <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p>Los números difusos triangulares se definen de la siguiente forma: <span class="citation" data-cites="fuzzyNum">(Anand and Bharatraj 2017)</span></p>
<p>Sea <span class="math inline">\tilde{A}</span> un número difuso triangular, el símbolo encima de la <span class="math inline">A</span> indica que se trata de un número difuso. Entonces <span class="math inline">\tilde{A} = (a,b,c)</span> donde <span class="math inline">a</span>, <span class="math inline">b</span>, y <span class="math inline">c</span> son tres números reales que conforman al número difuso.</p>
<p>Por otra parte sea <span class="math inline">x</span> cualquier número real, y sea <span class="math inline">\mu_{\tilde{A}}(x)</span> la función del grado de pertenencia de <span class="math inline">x</span> al número difuso <span class="math inline">\tilde{A}</span>, entonces:</p>
<p><span id="eq:fPert" class="eqnos"><span class="math display">
\mu_{\tilde{A}}(x) =
\begin{cases}
    0,                 &amp; x &lt; a;\\
    \frac{x-a}{b-a},   &amp; a \leq x \leq b;\\
    \frac{c-x}{c-b},   &amp; b &lt; x \leq c;\\
    0,                 &amp; x &gt; c,
\end{cases}
</span><span class="eqnos-number">(1)</span></span> </p>
<p>Como se observa en la ecuación (<a href="#eq:fPert">1</a>) la función del grado de pertenencia está entre 0 y 1. Antes de <span class="math inline">a</span> y después de <span class="math inline">c</span> su valor es 0, es decir que sólo tiene valor distinto de 0 entre <span class="math inline">a</span> y <span class="math inline">c</span>. Por otra parte, esta función del grado de pertenencia llega a un valor de 1 cuando <span class="math inline">x = b</span>, entre <span class="math inline">a</span> y <span class="math inline">b</span> el valor de la función va ascendiendo de 0 a 1, y entre <span class="math inline">b</span> y <span class="math inline">c</span> desciende de 1 a 0, lo que hace que efectivamente la función forme un triangulo que inicia en <span class="math inline">a</span>, tiene el máximo en <span class="math inline">b</span> y termina en <span class="math inline">c</span>. <span class="citation" data-cites="fuzzyNum">(Anand and Bharatraj 2017)</span></p>
<p>Haciendo uso de los números difusos triangulares, a continuación se define el modelo FMMSP <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>: <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p>Sea <span class="math inline">NT</span> el número de órdenes o trabajos a procesar, sea <span class="math inline">I</span> el conjunto de los trabajos, tal que <span class="math inline">I = \{1,2,\dots,i,\dots,NT\}</span> donde <span class="math inline">i</span> es cualquier trabajo del conjunto <span class="math inline">I</span>.</p>
<p>Sea <span class="math inline">L</span> el número de etapas por las que deben pasar los trabajos, sea <span class="math inline">S</span> el conjunto de las etapas, tal que <span class="math inline">S = \{1,2,\dots,s,\dots,L\}</span> donde <span class="math inline">s</span> es cualquier etapa del conjunto <span class="math inline">S</span>.</p>
<p>En cada etapa <span class="math inline">s</span> se presentan <span class="math inline">n_s</span> unidades de procesamiento paralelas, sea <span class="math inline">U_s</span> el conjunto de unidades de procesamiento de la etapa <span class="math inline">s</span>, tal que <span class="math inline">U_s = \{1,2,\dots,n_s\}</span>.</p>
<p>El tiempo de procesamiento del trabajo <span class="math inline">i</span> en la unidad <span class="math inline">u</span> es un número difuso triangular, por lo que se puede representar como: <span class="math inline">\tilde{T}_{i,u} = (T_{i,u}^{1},T_{i,u}^{2},T_{i,u}^{3})</span>. Notar que <span class="math inline">u</span> es cualquier unidad de todas las etapas, y no de una etapa en particular, es decir si se númeran todas las unidades o “máquinas” sin distinguir la etapa, entonces <span class="math inline">u</span> es uno de estos números, o sea <span class="math inline">u</span> es cualquier máquina de todo el sistema de producción. Las unidades que pertenecen a una etapa en particular se denotan con <span class="math inline">U_s</span>.</p>
<p>El tiempo de inicio del trabajo <span class="math inline">i</span> en la etapa <span class="math inline">s</span> también es un número difuso triangular y se representa como <span class="math inline">\widetilde{Ts}_{i,s}</span>, y el tiempo de terminación del trabajo <span class="math inline">i</span> en la etapa <span class="math inline">s</span> siendo un número difuso triangular se representa como <span class="math inline">\widetilde{Tf}_{i,s}</span></p>
<p>Para definir completamente el modelo hacen falta pocas variables, entre ellas una variable binaria, llamada <span class="math inline">Z_{i,u,s}</span>. Si la variable binaria es igual a 1 indica que el trabajo <span class="math inline">i</span> se procesará en la unidad <span class="math inline">u</span> de la etapa <span class="math inline">s</span>, en caso contrario si la variable es igual a 0 significa que el trabajo <span class="math inline">i</span> no será procesado en la unidad <span class="math inline">u</span> de la etapa <span class="math inline">s</span>. Sea <span class="math inline">F</span> el tiempo de terminación del último trabajo de la secuencia, por tanto <span class="math inline">F</span> es la función objetivo a minimizar, <span class="math inline">F</span> también es llamado el makespan. Y por último sea <span class="math inline">M</span> un número muy grande, normalmente conocido como gran <span class="math inline">M</span>.</p>
<p>Teniendo las definiciones anteriores, el modelo FMMSP es el siguiente:</p>
<p><span id="eq:objF" class="eqnos"><span class="math display"> min F = max(\widetilde{Tf}_{i,L}) \qquad\forall i \in I </span><span class="eqnos-number">(2)</span></span> </p>
<p><span id="eq:binU" class="eqnos"><span class="math display"> \sum_{u \in U_{s}} Z_{i,u,s} = 1 \qquad\forall i \in I, s \in S </span><span class="eqnos-number">(3)</span></span> </p>
<p><span id="eq:finT" class="eqnos"><span class="math display"> \widetilde{Tf}_{i,s} = \widetilde{Ts}_{i,s} + \sum_{u \in U_{s}} (Z_{i,u,s}*\tilde{T}_{i,u}) \qquad\forall i \in I, s \in S </span><span class="eqnos-number">(4)</span></span> </p>
<p><span id="eq:mismaU" class="eqnos"><span class="math display">
\widetilde{Tf}_{i,s} + M*(2-Z_{i,u,s} - Z_{j,u,s}) \leq \widetilde{Ts}_{j,s}
\qquad\forall i \in I, j \in I, i &lt; j, s \in S, u \in U_{s}    
</span><span class="eqnos-number">(5)</span></span> </p>
<p><span id="eq:iniSp1" class="eqnos"><span class="math display"> \widetilde{Tf}_{i,s} \leq \widetilde{Ts}_{i,s+1} \qquad\forall i \in I,s \in S </span><span class="eqnos-number">(6)</span></span> </p>
<p>La ecuación (<a href="#eq:objF">2</a>) es la función objetivo de minimizar el máximo de los tiempos de terminación de los trabajos en la etapa L, que es la última etapa. Luego la ecuación (<a href="#eq:binU">3</a>) establece que el trabajo <span class="math inline">i</span> en la etapa <span class="math inline">s</span> solamente se pueda realizar en una sola unidad <span class="math inline">u</span>. La ecuación (<a href="#eq:finT">4</a>) muestra el tiempo de terminación siendo igual al tiempo de inicio más el tiempo de procesamiento. La inecuación (<a href="#eq:mismaU">5</a>) es una restricción para el tiempo de inicio del trabajo <span class="math inline">j</span> si este se realiza en la misma unidad que un trabajo anterior <span class="math inline">i</span>. Por último la inecuación (<a href="#eq:iniSp1">6</a>) es una restricción al tiempo de inicio del trabajo <span class="math inline">i</span> en la etapa siguiente <span class="math inline">s+1</span> que lo hace ser mayor o igual que el tiempo de terminación del trabajo <span class="math inline">i</span> en la etapa <span class="math inline">s</span>. <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p>Teniendo definido el modelo <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>, para resolverlo hace falta saber exactamente qué se entiende por el máximo entre dos números difusos triangulares. Como en el modelo se calcula el máximo de los tiempos de terminación, y dichos tiempos son números difusos triangulares, entonces se requiere definir los operadores de comparación &lt;, y &gt; para números difusos triangulares. Solo es necesario definir un operador pues el otro es su negación. El operador &gt; se define de la siguiente manera: <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p>Sean <span class="math inline">\tilde{A} = (a^1,a^2,a^3)</span> y <span class="math inline">\tilde{B} = (b^1,b^2,b^3)</span>. Para establecer que <span class="math inline">\tilde{A} &gt; \tilde{B}</span> se dan los tres casos siguientes</p>
<p><span id="eq:compas" class="eqnos"><span class="math display">
    Si \left(\frac{a^1+2*a^2+a^3}{4}\right) &gt; \left(\frac{b^1+2*b^2+b^3}{4}\right), entonces\ \tilde{A} &gt; \tilde{B}\\
    \\
    Si \left(\frac{a^1+2*a^2+a^3}{4}\right) = \left(\frac{b^1+2*b^2+b^3}{4}\right), y\ a^2 &gt; b^2, entonces\ \tilde{A} &gt; \tilde{B}\\
    \\
    Si \left(\frac{a^1+2*a^2+a^3}{4}\right) = \left(\frac{b^1+2*b^2+b^3}{4}\right), y\ a^2 = b^2, a^3-a^1 &gt; b^3-b^1, entonces\ \tilde{A} &gt; \tilde{B}
</span><span class="eqnos-number">(7)</span></span> </p>
<p><strong>Algoritmo MNIG:</strong> El algoritmo MNIG se entiende dividido a su vez en cuatro algoritmos, cada uno realizando un rol diferente y al ser aplicados como se indica logran una solución. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>El primer algoritmo es llamado DNEH_SMR, sirve para obtener una secuencia de trabajos inicial promisoria en la región de búsqueda. DNEH_SMR significa “Distributed NEH with Small-Medium Rule” a su vez NEH proviene de “Nawaz, Enscore, Ham” que es un reconocido algoritmo para minimizar el makespan. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>El algoritmo MNIG usa su propia notación, que en ocasiones usa los mismos símbolos del modelo FMMSP <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>. En este trabajo se le dará prelación a los símbolos del modelo FMMSP, puesto que el algoritmo MNIG se está adaptando al modelo, así también se adaptarán los símbolos de modo que sean congruentes con los del modelo FMMSP.</p>
<p>Para entender el algoritmo DNEH_SMR se requieren algunos símbolos extra. Una secuencia de trabajos factible se denota como <span class="math inline">\pi</span>, entonces <span class="math inline">\pi</span> es una solución factible al problema. En el algoritmo DNEH_SMR se divide en dos la secuencia, el punto en que se divide es llamado <span class="math inline">k</span>, y es definido como <span class="math inline">k = \lfloor\frac{L}{2}\rfloor</span>. Luego en el algoritmo DNEH_SMR se promedian los tiempos de cada grupo de etapas: antes de <span class="math inline">k</span> y después de <span class="math inline">k</span>. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>En el modelo FMMSP <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span> no se consideran los tiempos de procesamiento por etapa sino por unidad (o máquina) por lo que se hace necesario modificar ligeramente el algoritmo DNEH_SMR. Para hacer un tiempo de procesamiento equivalente por etapa, partiendo de los tiempos por unidad, se promedian los tiempos de las unidades en la etapa, es decir <span class="math inline">\forall u \in U_{s}</span>, de este modo defínase <span class="math inline">\widetilde{Ta}_{i,s} = \frac{1}{n_s} *\sum_{u \in U_{s}} \widetilde{T}_{i,u}</span>. <span class="math inline">Ta</span> es por <span class="math inline">T average</span>. Esta modificación es válida porque en cada etapa las máquinas trabajan en paralelo, es decir, cuando un trabajo pasa por una etapa, solamente es procesado por una máquina, no por todas las máquinas, entonces el tiempo promedio por etapa representa el tiempo que en promedio pasan los trabajos en cada etapa.</p>
<p>Teniendo <span class="math inline">\widetilde{Ta}</span> se definen los tiempos de procesamiento promedio por grupo de etapas, para el primer grupo antes de <span class="math inline">k</span>, <span class="math inline">\widetilde{T}_{i,1}&#39; = \frac{1}{k}*\sum_{l=1}^{k} \widetilde{Ta}_{i,l}</span>, y para el segundo grupo después de <span class="math inline">k</span>, <span class="math inline">\widetilde{T}_{i,2}&#39; = \frac{1}{L-k}*\sum_{l = k+1}^{L} \widetilde{Ta}_{i,l}</span>. Nótese el símbolo prima para indicar que son los tiempos promedio de los grupos de etapas. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>Del algoritmo DNEH_SMR resulta una secuencia factible y además no aleatoria, pues intenta crear una solución inicial de calidad. Como parte de ello se crea una secuencia ordenando los trabajos, en orden ascendente del tiempo promedio en el grupo 2 <span class="math inline">\widetilde{T}_{i,2}&#39;</span>, sea dicha secuencia <span class="math inline">\pi_{re1}</span> donde <span class="math inline">re1</span> indica que es el primer reordenamiento de la secuencia. Para el segundo reordenamiento, <span class="math inline">\pi_{re2}</span> se consigue al tomar el primer trabajo y luego el trabajo de en medio de <span class="math inline">\pi_{re1}</span>, eliminando los trabajos tomados de <span class="math inline">\pi_{re1}</span>. Si el número de trabajos en el que se busca el trabajo de en medio es par, se puede tomar el trabajo que está antes de la mitad (pues cuando el número de trabajos que quedan es par existen dos trabajos en el medio, tomar el primero). El hecho de que se van eliminando los trabajos significa que solo hay que repetir la instrucción: tomar el primero, tomar el de en medio, tomar el primero, tomar el de en medio, hasta agotar los trabajos y así dar forma a <span class="math inline">\pi_{re2}</span>. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>Dado que el modelo FMMSP es un modelo para sistemas del tipo flow shop flexible, cada trabajo sigue una secuencia de máquinas, es decir, en este modelo cada solución es una secuencia de trabajos en donde cada trabajo tiene una secuencia de máquinas. Para elegir la secuencia de máquinas de un trabajo, en este documento se usará la regla de asignar un trabajo a la máquina que lo procese más pronto, incluyendo la posibilidad de esperar a que un trabajo anterior sea procesado en una máquina y que se asigne el siguiente trabajo a esa máquina, según lo que resulte en el menor tiempo final de procesamiento. Esto se representa en la notación del modelo con: <span class="math inline">Z_{i, u, s}</span>, porque el uso de la variable <span class="math inline">Z_{i, u, s}</span> en el modelo FMMSP muestra que es posible procesar dos trabajos diferentes al mismo tiempo en una misma etapa, usando dos máquinas diferentes.</p>
<p>Por último en el algoritmo, se toma cada trabajo, y se reinserta en cada posición y se deja en la posición en la que resulte el mínimo makespan. Sea <span class="math inline">\pi_{re3}</span> la secuencia resultante de estas reinserciones. El algoritmo DNEH_SMR retorna la secuencia <span class="math inline">\pi_{re3}</span> como su resultado. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>Teniendo los elementos anteriores, a continuación se presenta el algoritmo DNEH_SMR en su versión de pseudocódigo de Python:</p>
<hr />
<p><strong>Algoritmo 1</strong> DNEH_SMR en pseudocódigo Python</p>
<hr />
<div class="algoritmo">
<p><code>def</code> DNEH_SMR(todas las <span class="math inline">\widetilde{T}_{i,u}</span>):<br />
1: Computar <span class="math inline">k = \lfloor\frac{L}{2}\rfloor</span><br />
2: Computar <span class="math inline">\widetilde{Ta}_{i,s} = \frac{1}{n_s}*\sum_{u \in U_{s}} \widetilde{T}_{i,u} \forall i \in I, s \in S</span><br />
3: Computar <span class="math inline">\widetilde{T}_{i,1}&#39; = \frac{1}{k}*\sum_{l=1}^{k} \widetilde{Ta}_{i,l}</span>, y <span class="math inline">\widetilde{T}_{i,2}&#39; = \frac{1}{L-k}*\sum_{l = k+1}^{L} \widetilde{Ta}_{i,l}</span> <span class="math inline">\forall i \in I</span><br />
4: Ordenar los trabajos según el orden ascendente de <span class="math inline">\widetilde{T}_{i,2}&#39;</span>, guardando la secuencia en <span class="math inline">\pi_{re1}</span><br />
5: Crear la secuencia <span class="math inline">\pi_{re2}</span>, quitando el primer trabajo y luego el de en medio de <span class="math inline">\pi_{re1}</span>, y ponerlos en <span class="math inline">\pi_{re2}</span>, repetir con los trabajos restantes hasta que ya no queden trabajos en <span class="math inline">\pi_{re1}</span><br />
6: Copiar <span class="math inline">\pi_{re2}</span> en <span class="math inline">\pi_{re3}</span><br />
7: <code>for j in</code> <span class="math inline">\pi_{re3}</span>:<br />
8: Reinsertar j en cada posición de <span class="math inline">\pi_{re3}</span> y medir el makespan<br />
9: Dejar j en la posición con el mínimo makespan sin mover los trabajos de iteraciones anteriores<br />
10: <code>return</code> <span class="math inline">\pi_{re3}</span></p>
</div>
<hr />
<p>Por claridad en el paso 4 del algoritmo DNEH_SMR, si por ejemplo la secuencia <span class="math inline">\pi_{re1}</span> es la secuencia <span class="math inline">[1, 6, 2, 5, 4, 3]</span>, la secuencia <span class="math inline">\pi_{re2}</span> correspondiente será entonces <span class="math inline">[1, 5, 6, 4, 2, 3]</span>. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>Con el algoritmo DNEH_SMR se obtiene una solución inicial <span class="math inline">\pi_{re3}</span>. Este primer algoritmo, y los dos siguientes, algoritmos 1, 2, y 3 se integran en el algoritmo 4. Desde ya decir que el algoritmo 4 es el algoritmo MNIG. Para llevar a cabo el algoritmo MNIG hace falta mostrar otros dos algoritmos, los algoritmos 2 y 3 que serán trabajados a continuación.</p>
<p>Para hacer el algoritmo MNIG se necesita poder destruir y reconstruir la secuencia <span class="math inline">\pi_{re3}</span> reconstruyendo de modo que se vaya mejorando la función objetivo. La destrucción y reconstrucción de la secuencia se logran con el algoritmo 2. También se necesita hacer la búsqueda local con multi-vecindad, en la que se hacen inserciones e intercambios de trabajos en la secuencia, buscando la mejora en la función objetivo. Esta búsqueda local con multi-vecindad se realiza con el algoritmo 3. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>En el algoritmo 2, la destrucción y reconstrucción de una secuencia de trabajos tiene por objeto la mejora en la función objetivo. Para hacer este algoritmo de destrucción y reconstrucción, se comienza por remover <span class="math inline">d</span> trabajos de la secuencia de manera aleatoria. Con estos trabajos removidos se forma la secuencia <span class="math inline">\pi_{d}</span>. Con los trabajos restantes se forma la secuencia <span class="math inline">\pi_{r}</span>. Luego se toma cada trabajo en <span class="math inline">\pi_{d}</span> y se reinserta en cada posición de <span class="math inline">\pi_{r}</span>, se mide el makespan a pesar de que esta secuencia tenga menos trabajos que la original y se deja el trabajo en la posición que tenga el mínimo makespan. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>Luego cada trabajo en <span class="math inline">\pi_{r}</span> se reinserta en la secuencia bajo construcción, se mide el makespan, y si éste es menor que el makespan inicial entonces se inserta el el trabajo en la posición que haya generado el nuevo y mejor makespan. Se hace lo mismo con los restantes trabajos en <span class="math inline">\pi_{r}</span> sin reemplazar los que ya hayan sido insertados. Por último se repite este proceso con los demás trabajos en <span class="math inline">\pi_{d}</span>. La secuencia resultante es retornada por el algoritmo. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>Llámesele <span class="math inline">\pi_{input}</span> a la secuencia a ser destruida y reconstruida, y sea <span class="math inline">\pi_{desrec}</span> la secuencia retorna por el algoritmo 2 tras ser destruida y reconstruida. En consideración de lo dicho se presenta el algoritmo de destrucción y reconstrucción en su versión de pseudocódigo de Python:</p>
<hr />
<p><strong>Algoritmo 2</strong> Destrucción y reconstrucción de las secuencias</p>
<hr />
<div class="algoritmo">
<p>def destruction_reconstruction(<span class="math inline">\pi_{input}</span>, <span class="math inline">d</span>):<br />
1: Remover aleatoriamente <span class="math inline">d</span> trabajos de la secuencia <span class="math inline">\pi_{input}</span> y ponerlos en la secuencia <span class="math inline">\pi_{d}</span>. Poner el resto de trabajos en la secuencia <span class="math inline">\pi_{r}</span><br />
2: for j in <span class="math inline">\pi_{d}</span>:<br />
3: Reinsertar j en cada posición de <span class="math inline">\pi_{r}</span> y medir el makespan como <span class="math inline">fitness1</span><br />
4: Insertar j en la posición que tenga el mínimo <span class="math inline">fitness1</span><br />
5: for j2 in <span class="math inline">\pi_{r}</span> excepto los trabajos insertados de <span class="math inline">\pi_{d}</span>:<br />
6: Reinsertar j2 en cada posición de <span class="math inline">\pi_{r}</span> y medir el makespan como <span class="math inline">fitness2</span><br />
7: if (<span class="math inline">fitness2</span> &lt; <span class="math inline">fitness1</span>):<br />
8: Insertar j2 en la posición con el menor <span class="math inline">fitness2</span><br />
9: <span class="math inline">\pi_{desrec} = \pi_{r}</span><br />
10: return <span class="math inline">\pi_{desrec}</span></p>
</div>
<hr />
<p>El algoritmo 3 es el algoritmo de búsqueda local con multi-vecindad. En este algoritmo se toma una secuencia a ser procesada <span class="math inline">\pi_{input}</span>, y el algoritmo retorna una secuencia factible mejorada <span class="math inline">\pi_{multivec}</span>. En el algoritmo se le hacen dos tipos de operaciones a la secuencia: inserciones e intercambios de trabajos. Insertar un trabajo significa tomar un trabajo y ponerlo en otra posición, desplazando los demás trabajos hacia la derecha. Intercambiar dos trabajos implica tomar dos trabajos y cambiarlos de posición, el uno en la posición del otro. Sea <span class="math inline">\pi_{modif}</span> la secuencia tras ser modificada con alguna de estas operaciones, y <span class="math inline">\pi_{temp}</span> una secuencia para guardar un resultado temporal. Para este algoritmo, sea <span class="math inline">C_{max}(\pi) = F</span> para dejar a <span class="math inline">F</span> en función de la secuencia <span class="math inline">\pi</span>. <span class="math inline">C_{max}</span> es un símbolo común para el makespan. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>En el algoritmo de búsqueda local con multi-vecindad hay dos funciones clave, que realizan las operaciones de inserción y de intercambio de trabajos. La operación de inserción es realizada con la función <span class="math inline">Insertion_{inner}(\pi)</span>, en esta función se toma cada trabajo de <span class="math inline">\pi</span> y se inserta en cada posición, midiendo el makespan y al final, si el makespan mejora, se deja insertado el trabajo en la posición que tenga el menor makespan. La otra función es <span class="math inline">Swap_{inner}(\pi)</span> en la que se intercambian dos trabajos de <span class="math inline">\pi</span>, se mide el makespan, y al final dejando intercambiados los trabajos en donde se presente el menor makespan. Si después de aplicar estas funciones se encuentra mejora, la función vuelve a ser aplicada, hasta que no se presente mejora en el makespan. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>Con lo anterior, aquí el algoritmo de búsqueda local con multi-vecindad en su versión de pseudocódigo de Python:</p>
<hr />
<p><strong>Algoritmo 3</strong> Búsqueda local con multi-vecindad</p>
<hr />
<div class="algoritmo">
<p><code>def local_search(</code><span class="math inline">\pi_{input}</span><code>):</code><br />
<code>1:  |</code><span class="math inline">\pi_{modif} = \pi_{input}, l_{max} = 2, l = 1</span><br />
<code>2:  while (</code><span class="math inline">l</span><code>&lt;=</code><span class="math inline">l_{max}</span><code>):</code><br />
<code>3:      if (</code><span class="math inline">l</span><code>== 1):</code><br />
<code>4:          |</code><span class="math inline">\pi_{temp} = Insertion_{inner}(\pi_{modif})</span><br />
<code>5:      else if (</code><span class="math inline">l</span><code>== 2):</code><br />
<code>6:          |</code><span class="math inline">\pi_{temp} = Swap_{inner}(\pi_{modif})</span><br />
<code>7:      if (</code><span class="math inline">C_{max}(\pi_{temp}) &lt; C_{max}(\pi_{modif})</span><code>):</code><br />
<code>8:          |</code><span class="math inline">\pi_{modif} = \pi_{temp}, l = 1</span><br />
<code>9:      else:</code><br />
<code>10:         |</code><span class="math inline">l = l + 1</span><br />
<code>11: |</code><span class="math inline">\pi_{multivec} = \pi_{modif}</span><br />
<code>12: return</code><span class="math inline">\pi_{multivec}</span></p>
</div>
<hr />
<p>Teniendo los tres primeros algoritmos, el cuarto y último es la síntesis de los tres más algunas adiciones, por ello es llamado el algoritmo MNIG. Sea <span class="math inline">\pi_{result}</span> la secuencia final resultado de la aplicación del algoritmo MNIG. Para aplicar el algoritmo MNIG es necesario definir un criterio de terminación del algoritmo, pues en caso contrario el algoritmo nunca pararía de ejecutarse. En la literatura el criterio de terminación propuesto (ajustado para el modelo FMMSP <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>) es <span class="math inline">N^2*L*0.1ms</span> <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span>.</p>
<p>Este es un buen criterio, pero tiene dos problemas, primero no tiene en cuenta todas las partes del modelo FMMSP y segundo está en unidades de milisegundo. Para el primer problema, se puede incluir lo que falta del modelo FMMSP, las unidades (o máquinas). Sea <span class="math inline">UT = \sum_{s = 1}^{L}|U_{s}|</span>, <span class="math inline">UT</span> es el total de unidades. Lo segundo puede ser un problema porque si el algoritmo para según una cantidad de tiempo arbitraria en milisegundos, ello fuerza a escribir el código de modo que cada iteración dure el menor tiempo posible. Pero eso es una desventaja porque no se puede hacer que el algoritmo dé resultados parciales, pues imprimir resultados parciales toma tiempo, a pesar de que sea poco tiempo. Otra forma de hacerlo sería teniendo un criterio de terminación en número de iteraciones, o sea que el algoritmo pare luego de un número de iteraciones. Según lo anterior, un criterio de terminación para el algoritmo MNIG aplicado al modelo FMMSP podría ser <span class="math inline">Iterations = N^2*L*UT</span>.</p>
<p>Antes de proceder con el pseudocódigo del algoritmo MNIG falta decir que este algoritmo explora en la región de búsqueda, intentando no quedarse en óptimos locales. A este efecto, existe un criterio de aceptación de nuevas soluciones que incluye la posibilidad de aceptar soluciones peores con una baja probabilidad. Este criterio define un nuevo parámetro derivado <span class="math inline">T</span>, cuya ecuación es <span class="math inline">T = T_{0}*\frac{\sum_{i}\sum_{s}\widetilde{Ta}_{i,s}}{10*N*L}</span> Donde <span class="math inline">T_{0}</span> es un parámetro diferente de cero y no muy grande. <span class="citation" data-cites="algMNIG">(Shao, Shao, and Pi 2020)</span></p>
<p>Pseudocódigo de Python del algoritmo MNIG:</p>
<hr />
<p><strong>Algoritmo 4</strong> MNIG</p>
<hr />
<div class="algoritmo">
<p>def MNIG(todas las <span class="math inline">\widetilde{T}_{i,u}</span>, <span class="math inline">d</span>, <span class="math inline">T_{0}</span>):<br />
<code>1:  |</code><span class="math inline">\pi_{re3}</span> = DNEH_SMR(todas las <span class="math inline">\widetilde{T}_{i,u}</span>)<br />
<code>2:  |</code><span class="math inline">\pi_{result} = \pi_{re3}, \pi_{temp} = \pi_{re3}, iter = 1</span><br />
<code>3:  while</code> (<span class="math inline">iter &lt;= N^2*L*UT</span>):<br />
<code>4:      |</code><span class="math inline">\pi_{temp}</span> = local_search(<span class="math inline">\pi_{temp}</span>)<br />
<code>5:      if</code> (<span class="math inline">C_{max}(\pi_{temp}) &lt; C_{max}(\pi_{re3})</span>):<br />
<code>6:          |</code><span class="math inline">\pi_{re3} = \pi_{temp}</span><br />
<code>7:          if</code> (<span class="math inline">C_{max}(\pi_{temp}) &lt; C_{max}(\pi_{result})</span>):<br />
<code>8:              |</code><span class="math inline">\pi_{result} = \pi_{temp}</span><br />
<code>9:      else:</code><br />
<code>10:         if</code> (<span class="math inline">random(0,1) &lt; e^{\frac{-(C_{max}(\pi_{temp})-C_{max}(\pi_{re3}))}{T}}</span>):<br />
<code>11:             |</code><span class="math inline">\pi_{re3} = \pi_{temp}</span><br />
<code>12:     |</code><span class="math inline">\pi_{temp}</span> = destruction_reconstruction(<span class="math inline">\pi_{temp}</span>, <span class="math inline">d</span>)<br />
<code>13: return</code> <span class="math inline">\pi_{result}</span></p>
</div>
<hr />
<p><strong>Algoritmos BSA en general:</strong> Los algoritmos BSA, por sus siglas en inglés que significan Backtracking Search Algorithm, son algoritmos que al ser aplicados a problemas de Scheduling, constan de 5 pasos: inicialización, selección-I, mutación, cruzamiento, y selección-II. <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p>La inicialización genera la población de secuencias. El paso selección-I actualiza la población de secuencias si es necesario, usando la memoria de la información histórica que guarda un algoritmo BSA. Dicha memoria también se usa para construir o cambiar la dirección de búsqueda de soluciones. El paso mutación genera una nueva población de secuencias mutando o alterando la población recibida del paso anterior. El paso cruzamiento cruza las secuencias unas con otras para obtener nuevas secuencias, descartando las secuencias no factibles. Por último, el paso de selección-II compara el makespan de las nuevas secuencias respecto a la población de secuencias del paso selección-I, y las mejores secuencias son elegidas para la iteración siguiente. <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p>Tres de los cuatro algoritmos de comparación en este trabajo, son algoritmos de tipo BSA.</p>
<p><strong>Algoritmo DBSA-LS:</strong> El algoritmo DBSA-LS, por sus siglas en inglés que significan Discrete Backtracking Search Algorithm with Local Search, es un algoritmo que busca aumentar la velocidad de convergencia del algoritmo BSA. Para ello, el algoritmo DBSA-LS utiliza la mejor secuencia de cada iteración, conocida como la secuencia Gbest. Aparte de esto, el algoritmo DBSA-LS utiliza búsqueda local para mejorar la de exploración de soluciones. <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p><strong>Algoritmo BDBSA:</strong> El algoritmo BDBSA, por sus siglas en inglés que significan Basic Discrete Backtracking Search Algorithm, es un algoritmo tipo BSA que aplica los mismos cinco pasos del algoritmo BSA a problemas de tiempo discreto. Este algoritmo puede ser aplicado a problemas de scheduling en los que los trabajos inician y terminan en unidades de tiempo discretos. <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p><strong>Algoritmo MBSA:</strong> El algoritmo MBSA, por sus siglas en inglés que significan Modified Backtracking Search Algorithm, es una forma modificada del algoritmo BSA. Esta modificación no cambia los cinco pasos esenciales del algoritmo BSA. <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p><strong>Algoritmo IGA:</strong> El algoritmo IGA, por sus siglas en inglés que significan Interactive Genetic Algorithm, es un algoritmo genético que tiene algunas similaridades con el algoritmo BSA. Por ejemplo, en el algoritmo IGA las secuencias son modificadas mediante mutaciones aleatorias, y las mejores secuencias según el makespan pasan a la siguiente iteración. Esto también ocurre en el algoritmo BSA. <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p>Esto termina la presentación del modelo FMMSP denotado como <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>, el algoritmo MNIG, y los cuatro algoritmos DBSA-LS, BDBSA, MBSA, e IGA. Con este marco de referencia se llevó a cabo el proyecto de grado.</p>
<h1 id="hipótesis">HIPÓTESIS</h1>
<p>A través del algoritmo MNIG se pueden encontrar soluciones para el modelo FMMSP <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>. Tras su aplicación la efectividad del algoritmo MNIG es medible y es comparable a la efectividad de los otros cuatro algoritmos: DBSA-LS, BDBSA, MBSA, e IGA.</p>
<h1 id="diseño-metodológico">DISEÑO METODOLÓGICO</h1>
<p>El diseño metodológico de este proyecto abarca tres partes principales: escribir el algoritmo MNIG en Python, ejecutar el algoritmo MNIG en una instancia del modelo FMMSP, y comparar los resultados del algoritmo MNIG con los resultados de los otros cuatro algoritmos que ya han sido aplicados al modelo FMMSP (DBSA-LS, BDBSA, MBSA, e IGA).</p>
<h2 id="escritura-del-algoritmo-mnig-en-python">Escritura del algoritmo MNIG en Python</h2>
<p>El algoritmo MNIG se escribió en el lenguaje Python como una aplicación de consola. El interprete de Python empieza por ejecutar un archivo de texto plano de Python, en que se encuentran los parámetros del modelo <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>, en particular los tiempos de procesamiento, el número de etapas, el número de unidades por etapa. A su vez, los siguientes parámetros son pasados al programa por medio de la interfaz de línea de comandos, para así tener mayor facilidad para modificar estos parámetros y hacer pruebas: el parámetro de número de iteraciones <span class="math inline">N</span>, el número de trabajos a remover en el algoritmo de destrucción y reconstrucción <span class="math inline">d</span>, y el parámetro <span class="math inline">T_{0}</span>.</p>
<p>La jerarquía de archivos del programa es:</p>
<pre><code>MNIG_to_FMMSP/
  __main__.py
  API/
    functions.py
  algorithms/
    __init__.py
    DNEH_SMR.py
    destruction_reconstruction.py
    local_search.py</code></pre>
<p>En esta estructura, cada algoritmo tiene su propio archivo, y el archivo que tiene el algoritmo MNIG como síntesis de los demás es el archivo <code>__main__.py</code> desde este archivo se llama a los demás algoritmos.</p>
<p>La carpeta <code>API/</code> contiene el archivo <code>functions.py</code>, en el cual se definen funciones comunes a todos los algoritmos, por ejemplo la funcion <code>makespan()</code> que puede ser usada desde cualquier algoritmo que lo necesite, para calcular el makespan de una secuencia dada.</p>
<p>Usando la opción <code>--debug</code>, el programa va imprimiendo en la terminal resultados parciales de cada iteración, específicamente la secuencia encontrada con el mínimo makespan en esa iteración. Al finalizar la ejecución del programa, queda impreso en pantalla la secuencia final así como su makespan.</p>
<p>Como se observa en la estructura de archivos, la carpeta <code>algorithms/</code> es tratada como un paquete mediante el archivo <code>__init__.py</code> se podría decir que es el paquete con los algoritmos necesarios para ejecutar el algoritmo principal MNIG.</p>
<h2 id="ejecución-del-algoritmo-mnig-en-instancia-del-modelo-fmmsp">Ejecución del algoritmo MNIG en instancia del modelo FMMSP</h2>
<p>Aquí se explica por qué sólo se trabajará una instancia y no varias del modelo FMMSP <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>. La razón es que sólo existe una instancia públicamente a nivel internacional. Ello porque aunque en la literatura se habla de varias instancias (de unas 15 instancias), sólo en 1 se dan los datos, en el resto se dice que fueron generadas con números aleatorios uniformes con ciertas condiciones, pero instancias creadas aleatoriamente no pueden ser replicadas con exactitud. <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<p>Por lo anterior se ejecutará el algoritmo MNIG en la única instancia conocida del modelo FMMSP <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>. En la literatura las instancias son nombradas con 3 letras y un número por letra, por ejemplo la instancia que se trabajará es “o10s2u5.” En esta cadena de caracteres, “o” significa “ordenes” (o trabajos), “s” significa etapas (stages en inglés), “u” significa “unidades” (o máquinas). Por ende la instancia sobre la que se probará el algoritmo es de 10 trabajos, 2 etapas, y 5 unidades. La siguiente tabla contiene los datos de la instancia: <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<table>
<caption>Tiempos de procesamiento de la instancia o10s2u5</caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Trabajo</th>
<th style="text-align: center;">Unidad 1 Etapa 1</th>
<th style="text-align: center;">Unidad 2 Etapa 1</th>
<th style="text-align: center;">Unidad 3 Etapa 2</th>
<th style="text-align: center;">Unidad 4 Etapa 2</th>
<th style="text-align: center;">Unidad 5 Etapa 2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">(10,12,13)</td>
<td style="text-align: center;">(11,12,14)</td>
<td style="text-align: center;">(9,10,12)</td>
<td style="text-align: center;">(6,7,9)</td>
<td style="text-align: center;">(8,9,10)</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">(7,8,10)</td>
<td style="text-align: center;">(8,9,10)</td>
<td style="text-align: center;">(5,6,8)</td>
<td style="text-align: center;">(4,5,6)</td>
<td style="text-align: center;">(4,5,6)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">(10,11,12)</td>
<td style="text-align: center;">(9,10,12)</td>
<td style="text-align: center;">(2,3,4)</td>
<td style="text-align: center;">(5,6,8)</td>
<td style="text-align: center;">(5,6,7)</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">(8,9,10)</td>
<td style="text-align: center;">(6,7,8)</td>
<td style="text-align: center;">(7,8,9)</td>
<td style="text-align: center;">(4,5,6)</td>
<td style="text-align: center;">(5,6,8)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">(6,7,8)</td>
<td style="text-align: center;">(8,9,10)</td>
<td style="text-align: center;">(4,5,6)</td>
<td style="text-align: center;">(6,7,8)</td>
<td style="text-align: center;">(6,7,9)</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">(4,5,6)</td>
<td style="text-align: center;">(2,3,4)</td>
<td style="text-align: center;">(15,16,19)</td>
<td style="text-align: center;">(13,14,15)</td>
<td style="text-align: center;">(15,16,20)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">(11,13,15)</td>
<td style="text-align: center;">(1,2,3)</td>
<td style="text-align: center;">(11,13,14)</td>
<td style="text-align: center;">(10,11,13)</td>
<td style="text-align: center;">(9,10,12)</td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: center;">(10,11,12)</td>
<td style="text-align: center;">(18,19,23)</td>
<td style="text-align: center;">(5,6,7)</td>
<td style="text-align: center;">(6,7,9)</td>
<td style="text-align: center;">(7,8,10)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">9</td>
<td style="text-align: center;">(5,6,8)</td>
<td style="text-align: center;">(4,5,6)</td>
<td style="text-align: center;">(14,15,16)</td>
<td style="text-align: center;">(19,21,25)</td>
<td style="text-align: center;">(10,12,13)</td>
</tr>
<tr class="even">
<td style="text-align: center;">10</td>
<td style="text-align: center;">(15,17,20)</td>
<td style="text-align: center;">(12,14,15)</td>
<td style="text-align: center;">(16,17,20)</td>
<td style="text-align: center;">(17,18,21)</td>
<td style="text-align: center;">(18,19,21)</td>
</tr>
</tbody>
</table>
<p>Recordar que los tiempos de procesamiento vienen en ternas en la tabla pues son números difusos triangulares. El algoritmo será ejecutado sobre esta instancia o10s2u5 y se guardará el resultado en un archivo para compararlo con los de los otros cuatro algoritmos.</p>
<h2 id="comparación-del-algoritmo-mnig-con-otros-algoritmos">Comparación del algoritmo MNIG con otros algoritmos</h2>
<p>Tras aplicar el algoritmo MNIG a la instancia del modelo FMMSP y obtener resultados, se podrá comparar a otros cuatro algoritmos. Estos son: DBSA-LS, BDBSA, MBSA, e IGA. Estos cuatro algoritmos ya fueron aplicados a la instancia del modelo FMMSP. En la siguiente tabla se presentan los resultados de esos cuatro algoritmos: <span class="citation" data-cites="modFMMSP">(Yan, Han, and Gu 2020)</span></p>
<table>
<caption>Resultados del makespan de los cuatro algoritmos en la instancia o10s2u5</caption>
<thead>
<tr class="header">
<th style="text-align: center;">Algoritmo</th>
<th style="text-align: center;">Mejor valor</th>
<th style="text-align: center;">Valor medio</th>
<th style="text-align: center;">Peor valor</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">DBSA-LS</td>
<td style="text-align: center;">(36,44,52)</td>
<td style="text-align: center;">(38,45,52)</td>
<td style="text-align: center;">(42,48,53)</td>
</tr>
<tr class="even">
<td style="text-align: center;">BDBSA</td>
<td style="text-align: center;">(36,44,52)</td>
<td style="text-align: center;">(38.6,45.5,52)</td>
<td style="text-align: center;">(40,46,54)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">MBSA</td>
<td style="text-align: center;">(40,47,55)</td>
<td style="text-align: center;">(44,50,57)</td>
<td style="text-align: center;">(42.2,49.3,54.6)</td>
</tr>
<tr class="even">
<td style="text-align: center;">IGA</td>
<td style="text-align: center;">(39,45,52)</td>
<td style="text-align: center;">(40.1,46.9,54.5)</td>
<td style="text-align: center;">(43,49,57)</td>
</tr>
</tbody>
</table>
<p>Con esta tabla se compararán directamente los resultados del algoritmo MNIG al ser aplicado al modelo FMMSP <span class="math inline">FFc | \tilde{T}_{i, u}, batch(b), Z_{i, u, s} | C_{max}</span>.</p>
<h2 id="instancias-de-taillard">Instancias de Taillard</h2>
<p>A nivel internacional, se reconocen algunas instancias con las que se puede medir la efectividad de las metaheurísticas. Para el caso flow shop, las instancias de Taillard son instancias que se han venido usando desde 1993 cuando fueron creadas, son en total 12 instancias. La más pequeña cuenta con 20 trabajos y 5 máquinas. La instancia más grande es de 500 trabajos y 20 máquinas. Se aplicará el algoritmo MNIG a estas instancias aunque no esté diseñado para resolver el modelo flow shop básico, pues esto permitirá comprobar que el algoritmo MNIG puede ser aplicado a sistemas tipo flow shop.</p>
<h1 id="resultados">RESULTADOS</h1>
<h1 id="conclusiones-y-recomendaciones">CONCLUSIONES Y RECOMENDACIONES</h1>
<h1 id="glosario-de-anglicismos">GLOSARIO DE ANGLICISMOS</h1>
<h1 class="unnumbered" id="referencias">REFERENCIAS</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-fuzzyNum" class="csl-entry" role="doc-biblioentry">
Anand, M. Clement, and Janani Bharatraj. 2017. <span>“Theory of Triangular Fuzzy Number.”</span> In.
</div>
<div id="ref-flowCompl" class="csl-entry" role="doc-biblioentry">
Garey, M., D. Jhonson, and R. Sethi. 1976. <span>“The Complexity of Flowshop and Jobshop Scheduling.”</span> <em>Mathematics of Operations Research</em> 1 (2): 117, 129.
</div>
<div id="ref-schedPinedo" class="csl-entry" role="doc-biblioentry">
Pinedo, Michael. 2016. <em>Scheduling, Theory, Algorithms, and Systems</em>. 5th ed. New York, USA: Springer.
</div>
<div id="ref-algMNIG" class="csl-entry" role="doc-biblioentry">
Shao, Weishi, Zhongshi Shao, and Dechang Pi. 2020. <span>“Modeling and Multi Neighborhood Iterated Greedy Algorithm for Distributed Hybrid Flow Shop Scheduling Problem.”</span> <em>Knowledge-Based Systems</em>. https://doi.org/<a href="https://doi.org/10.1016/j.knosys.2020.105527">https://doi.org/10.1016/j.knosys.2020.105527</a>.
</div>
<div id="ref-instTaillard" class="csl-entry" role="doc-biblioentry">
Taillard, E. 1993. <span>“Benchmarks for Basic Scheduling Problems.”</span> <em>EJOR</em> 64 (2): 278, 285.
</div>
<div id="ref-metaTalbi" class="csl-entry" role="doc-biblioentry">
Talbi, El-Ghazali. 2009. <em>Metaheuristics, From Design to Implementation</em>. 1st ed. USA: Wiley.
</div>
<div id="ref-modFMMSP" class="csl-entry" role="doc-biblioentry">
Yan, Xueli, Yuxin Han, and Xingsheng Gu. 2020. <span>“An Improved Discrete Backtracking Searching Algorithm for Fuzzy Multiproduct Multistage Scheduling Problem.”</span> <em>Neurocomputing</em>. https://doi.org/<a href="https://doi.org/10.1016/j.neucom.2020.02.066">https://doi.org/10.1016/j.neucom.2020.02.066</a>.
</div>
</div>
</body>
</html>
